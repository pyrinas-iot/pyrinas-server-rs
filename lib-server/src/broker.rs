// System related
use log::debug;
use std::collections::hash_map::{Entry, HashMap};

// Channels
use flume::{Receiver, Sender};

// Error
use anyhow::{anyhow, Result};

// Local lib related
use pyrinas_shared::Event;

pub async fn run(broker_reciever: Receiver<Event>) {
    let mut runners: HashMap<String, Sender<Event>> = HashMap::new();

    // Handle broker events
    while let Ok(event) = broker_reciever.recv_async().await {
        match event.clone() {
            // Upon creating a new server thread, the thread has to register with the broker.
            Event::NewRunner { name, sender } => {
                // Check to see if the runner is already in the HashMap
                match runners.entry(name.clone()) {
                    Entry::Occupied(..) => (),
                    Entry::Vacant(entry) => {
                        // Inserts the Sender<event> into the HashMap
                        debug!("Adding {} to broker.", name);
                        entry.insert(sender);
                    }
                }
            }
            // Handle OtaNewPackage generated by sock_run
            Event::OtaNewPackage(_update) => {
                debug!("broker_run: Event::OtaNewPackage");

                // Send to ota task
                if let Err(e) = send("ota", &event, &mut runners).await {
                    log::error!("{}", e);
                }
            }
            Event::OtaResponse(_update) => {
                // Send to mqtt
                if let Err(e) = send("mqtt", &event, &mut runners).await {
                    log::error!("{}", e);
                }
            }
            Event::OtaRequest { uid: _, msg: _ } => {
                debug!("broker_run: OtaRequest");

                // Send to sled
                if let Err(e) = send("ota", &event, &mut runners).await {
                    log::error!("{}", e);
                }
            }
            Event::InfluxDataSave(_query) => {
                debug!("broker_run: InfluxDataSave");

                // Send to influx
                if let Err(e) = send("influx", &event, &mut runners).await {
                    log::error!("{}", e);
                }
            }
            Event::ApplicationManagementRequest(_data) => {
                debug!("broker_run: ApplicationManagementRequest");

                // Send to app handler
                if let Err(e) = send("app", &event, &mut runners).await {
                    log::error!("{}", e);
                }
            }
            Event::ApplicationManagementResponse(_data) => {
                debug!("broker_run: ApplicationManagementResponse");

                // Send to app handler
                if let Err(e) = send("sock", &event, &mut runners).await {
                    log::error!("{}", e);
                }
            }
            Event::ApplicationRequest(_data) => {
                debug!("broker_run: ApplicationRequest");

                // Send to app handler
                if let Err(e) = send("app", &event, &mut runners).await {
                    log::error!("{}", e);
                }
            }
            Event::ApplicationResponse(_data) => {
                debug!("broker_run: ApplicationResponse");
                // Send to mqtt handler
                if let Err(e) = send("mqtt", &event, &mut runners).await {
                    log::error!("{}", e);
                }
            }
            _ => (),
        }
    }
}

/// Local only function to search for and find the corresponding sender
async fn send(
    task_name: &str,
    event: &Event,
    runners: &mut HashMap<String, Sender<Event>>,
) -> Result<()> {
    match runners.get_mut(task_name) {
        Some(sender) => {
            sender.send_async(event.clone()).await?;
            Ok(())
        }
        None => Err(anyhow!("{} broker task not registered!", task_name)),
    }
}
